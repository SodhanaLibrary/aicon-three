<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Animaticon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="index.css"/>
  <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="layout.css"/>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.10/css/all.css" integrity="sha384-+d0P83n9kaQMCwj8F4RJB66tzIwOKmrdb46+porD/OvrJ+37WqIM7UoBtwHO6Nlg" crossorigin="anonymous">
  <script type="text/javascript">
    window.animaticonObjects = {};
  </script>
  <script src="paper/paper-full.min.js" type="text/javascript"></script>
  <script src="three/three.min.js" type="text/javascript"></script>
<body>
  <script>
  			var container;
  			var camera, scene, renderer;
  			var group;
  			var mouseX = 0;
  			init();
  			function init() {
  				container = document.createElement( 'div' );
  				document.body.appendChild( container );

          var info = document.createElement( 'div' );
  				info.style.position = 'absolute';
  				info.style.top = '10px';
  				info.style.width = '100%';
  				info.style.textAlign = 'center';
  				info.innerHTML = 'Simple procedurally-generated shapes<br/>Drag to spin';
  				container.appendChild( info );

          scene = new THREE.Scene();
  				scene.background = new THREE.Color( 0xf0f0f0 );
          camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
          camera.position.set( 0, 0, 900 );
  				scene.add( camera );
  				group = new THREE.Group();
  				group.position.y = 0;
  				scene.add( group );
  				function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {
  					// flat shape with texture
  					// note: default UVs generated by ShapeBufferGeometry are simply the x- and y-coordinates of the vertices
  					var geometry = new THREE.ShapeBufferGeometry( shape );
  					var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color:0x000000 } ) );
  					mesh.position.set( x, y, z );
  					mesh.rotation.set( rx, ry, rz );
  					mesh.scale.set( s, s, s );
  					group.add( mesh );
  					addLineShape( shape, color, x, y, z, rx, ry, rz, s );
  				}
  				function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {
  					// lines
  					shape.autoClose = true;
  					var points = shape.getPoints();
  					var spacedPoints = shape.getSpacedPoints( 50 );
  					var geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
  					var geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );
  					var line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 10 } ) );
  					line.position.set( x, y, z + 1 );
  					line.rotation.set( rx, ry, rz );
  					line.scale.set( s, s, s );
  					group.add( line );
  				}
          function createGeometry ( sizing ) {
    				// var geometry = new THREE.CylinderGeometry(
    				// 	50,                       // radiusTop
    				// 	50,                       // radiusBottom
    				// 	sizing.height,           // height
    				// 	8,                       // radiusSegments
    				// 	sizing.segmentCount * 6, // heightSegments
    				// 	true                     // openEnded
    				// );

            var geometry = new THREE.PlaneGeometry( 50, sizing.height, 1, 2);

    				for ( var i = 0; i < geometry.vertices.length; i ++ ) {
    					var vertex = geometry.vertices[ i ];
    					var y = ( vertex.y + sizing.halfHeight );
    					var skinIndex = Math.floor( y / sizing.segmentHeight );
    					var skinWeight = ( y % sizing.segmentHeight ) / sizing.segmentHeight;
    					geometry.skinIndices.push( new THREE.Vector4( skinIndex, skinIndex + 1, 0, 0 ) );
    					geometry.skinWeights.push( new THREE.Vector4( 1 - skinWeight, skinWeight, 0, 0 ) );
    				}
    				return geometry;
    			}

    			function createBones ( sizing ) {
    				bones = [];
    				var prevBone = new THREE.Bone();
    				bones.push( prevBone );
    				prevBone.position.y = - sizing.halfHeight;
    				for ( var i = 0; i < sizing.segmentCount; i ++ ) {
    					var bone = new THREE.Bone();
    					bone.position.y = sizing.segmentHeight;
    					bones.push( bone );
    					prevBone.add( bone );
    					prevBone = bone;
    				}
    				return bones;
    			}

    			function createMesh ( geometry, bones ) {
    				var material = new THREE.MeshPhongMaterial( {
    					skinning : true,
    					color: 0x156289,
    					emissive: 0x072534,
    					side: THREE.DoubleSide,
    					flatShading: true
    				} );
    				var mesh = new THREE.SkinnedMesh( geometry,	material );
    				var skeleton = new THREE.Skeleton( bones );
    				mesh.add( bones[ 0 ] );
    				mesh.bind( skeleton );
    				skeletonHelper = new THREE.SkeletonHelper( mesh );
    				skeletonHelper.material.linewidth = 2;
    				scene.add( skeletonHelper );
    				return mesh;
    			}

          function initBones() {
    				var segmentHeight =100;
    				var segmentCount = 2;
    				var height = segmentHeight * segmentCount;
    				var halfHeight = height * 0.5;
    				var sizing = {
    					segmentHeight : segmentHeight,
    					segmentCount : segmentCount,
    					height : height,
    					halfHeight : halfHeight
    				};
    				var geometry = createGeometry( sizing );
    				var bones = createBones( sizing );
    				mesh = createMesh( geometry, bones );
    				mesh.scale.multiplyScalar( 1 );
    				scene.add( mesh );
    			}

          initBones();

  				// Track
  				var trackShape = new THREE.Shape();
  				trackShape.moveTo( 40, 40 );
  				trackShape.lineTo( 40, 160 );
  				trackShape.absarc( 60, 160, 20, Math.PI, 0, true );
  				trackShape.lineTo( 80, 40 );
  				trackShape.absarc( 60, 40, 20, 2 * Math.PI, Math.PI, true );
  				var extrudeSettings = { amount: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
  				addShape( trackShape,       extrudeSettings, 0x008080,  200, -100, 0, 0, 0, 0, 1 );
          addShape( trackShape,       extrudeSettings, 0x008080,  200, -150, 0, 0, 0, 0, 1 );


  				renderer = new THREE.WebGLRenderer( { antialias: true } );
  				renderer.setPixelRatio( window.devicePixelRatio );
  				renderer.setSize( window.innerWidth, window.innerHeight );
  				container.appendChild( renderer.domElement );
  				window.addEventListener( 'resize', onWindowResize, false );
  			}
  			function onWindowResize() {
  				camera.aspect = window.innerWidth / window.innerHeight;
  				camera.updateProjectionMatrix();
  				renderer.setSize( window.innerWidth, window.innerHeight );
  			}

        function render () {
  				requestAnimationFrame( render );
  				var time = Date.now() * 0.001;
  				//Wiggle the bones
					//for ( var i = 0; i < mesh.skeleton.bones.length; i ++ ) {
						mesh.skeleton.bones[ 1 ].rotation.z = Math.sin( time ) * 2 / mesh.skeleton.bones.length;
					//}
  				renderer.render( scene, camera );
  			}
        render();

  		</script>
</html>
